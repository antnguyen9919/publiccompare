{"version":3,"file":"stackdriverPlugin.ec7deb84f65ee765b2e6.js","sources":["webpack:///./public/app/plugins/datasource/stackdriver/StackdriverMetricFindQuery.ts","webpack:///./public/app/plugins/datasource/stackdriver/annotations_query_ctrl.ts","webpack:///./public/app/plugins/datasource/stackdriver/components/VariableQueryEditor.tsx","webpack:///./public/app/plugins/datasource/stackdriver/config_ctrl.ts","webpack:///./public/app/plugins/datasource/stackdriver/datasource.ts","webpack:///./public/app/plugins/datasource/stackdriver/module.ts","webpack:///./public/app/plugins/datasource/stackdriver/query_ctrl.ts","webpack:///./public/app/plugins/datasource/stackdriver/types.ts"],"sourcesContent":["import isString from 'lodash/isString';\nimport { alignmentPeriods } from './constants';\nimport { MetricFindQueryTypes } from './types';\nimport {\n  getMetricTypesByService,\n  getAlignmentOptionsByMetric,\n  getAggregationOptionsByMetric,\n  extractServicesFromMetricDescriptors,\n  getLabelKeys,\n} from './functions';\n\nexport default class StackdriverMetricFindQuery {\n  constructor(private datasource: any) {}\n\n  async execute(query: any) {\n    try {\n      switch (query.selectedQueryType) {\n        case MetricFindQueryTypes.Services:\n          return this.handleServiceQuery();\n        case MetricFindQueryTypes.MetricTypes:\n          return this.handleMetricTypesQuery(query);\n        case MetricFindQueryTypes.LabelKeys:\n          return this.handleLabelKeysQuery(query);\n        case MetricFindQueryTypes.LabelValues:\n          return this.handleLabelValuesQuery(query);\n        case MetricFindQueryTypes.ResourceTypes:\n          return this.handleResourceTypeQuery(query);\n        case MetricFindQueryTypes.Aligners:\n          return this.handleAlignersQuery(query);\n        case MetricFindQueryTypes.AlignmentPeriods:\n          return this.handleAlignmentPeriodQuery();\n        case MetricFindQueryTypes.Aggregations:\n          return this.handleAggregationQuery(query);\n        default:\n          return [];\n      }\n    } catch (error) {\n      console.error(`Could not run StackdriverMetricFindQuery ${query}`, error);\n      return [];\n    }\n  }\n\n  async handleServiceQuery() {\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\n    const services: any[] = extractServicesFromMetricDescriptors(metricDescriptors);\n    return services.map(s => ({\n      text: s.serviceShortName,\n      value: s.service,\n      expandable: true,\n    }));\n  }\n\n  async handleMetricTypesQuery({ selectedService }: any) {\n    if (!selectedService) {\n      return [];\n    }\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\n    return getMetricTypesByService(metricDescriptors, this.datasource.templateSrv.replace(selectedService)).map(\n      (s: any) => ({\n        text: s.displayName,\n        value: s.type,\n        expandable: true,\n      })\n    );\n  }\n\n  async handleLabelKeysQuery({ selectedMetricType }: any) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const labelKeys = await getLabelKeys(this.datasource, selectedMetricType);\n    return labelKeys.map(this.toFindQueryResult);\n  }\n\n  async handleLabelValuesQuery({ selectedMetricType, labelKey }: any) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const refId = 'handleLabelValuesQuery';\n    const labels = await this.datasource.getLabels(selectedMetricType, refId, [labelKey]);\n    const interpolatedKey = this.datasource.templateSrv.replace(labelKey);\n    const values = labels.hasOwnProperty(interpolatedKey) ? labels[interpolatedKey] : [];\n    return values.map(this.toFindQueryResult);\n  }\n\n  async handleResourceTypeQuery({ selectedMetricType }: any) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const refId = 'handleResourceTypeQueryQueryType';\n    const labels = await this.datasource.getLabels(selectedMetricType, refId);\n    return labels['resource.type'].map(this.toFindQueryResult);\n  }\n\n  async handleAlignersQuery({ selectedMetricType }: any) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\n    const { valueType, metricKind } = metricDescriptors.find(\n      (m: any) => m.type === this.datasource.templateSrv.replace(selectedMetricType)\n    );\n    return getAlignmentOptionsByMetric(valueType, metricKind).map(this.toFindQueryResult);\n  }\n\n  async handleAggregationQuery({ selectedMetricType }: any) {\n    if (!selectedMetricType) {\n      return [];\n    }\n    const metricDescriptors = await this.datasource.getMetricTypes(this.datasource.projectName);\n    const { valueType, metricKind } = metricDescriptors.find(\n      (m: any) => m.type === this.datasource.templateSrv.replace(selectedMetricType)\n    );\n    return getAggregationOptionsByMetric(valueType, metricKind).map(this.toFindQueryResult);\n  }\n\n  handleAlignmentPeriodQuery() {\n    return alignmentPeriods.map(this.toFindQueryResult);\n  }\n\n  toFindQueryResult(x: any) {\n    return isString(x) ? { text: x, expandable: true } : { ...x, expandable: true };\n  }\n}\n","import { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport class StackdriverAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  annotation: any;\n  templateSrv: TemplateSrv;\n\n  /** @ngInject */\n  constructor() {\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(target: any) {\n    Object.assign(this.annotation.target, target);\n  }\n}\n","import React, { ChangeEvent, PureComponent } from 'react';\nimport { VariableQueryProps } from 'app/types/plugins';\nimport { SimpleSelect } from './';\nimport { getMetricTypes, getLabelKeys, extractServicesFromMetricDescriptors } from '../functions';\nimport { MetricFindQueryTypes, VariableQueryData } from '../types';\n\nexport class StackdriverVariableQueryEditor extends PureComponent<VariableQueryProps, VariableQueryData> {\n  queryTypes: Array<{ value: string; name: string }> = [\n    { value: MetricFindQueryTypes.Services, name: 'Services' },\n    { value: MetricFindQueryTypes.MetricTypes, name: 'Metric Types' },\n    { value: MetricFindQueryTypes.LabelKeys, name: 'Label Keys' },\n    { value: MetricFindQueryTypes.LabelValues, name: 'Label Values' },\n    { value: MetricFindQueryTypes.ResourceTypes, name: 'Resource Types' },\n    { value: MetricFindQueryTypes.Aggregations, name: 'Aggregations' },\n    { value: MetricFindQueryTypes.Aligners, name: 'Aligners' },\n    { value: MetricFindQueryTypes.AlignmentPeriods, name: 'Alignment Periods' },\n  ];\n\n  defaults: VariableQueryData = {\n    selectedQueryType: this.queryTypes[0].value,\n    metricDescriptors: [],\n    selectedService: '',\n    selectedMetricType: '',\n    labels: [],\n    labelKey: '',\n    metricTypes: [],\n    services: [],\n  };\n\n  constructor(props: VariableQueryProps) {\n    super(props);\n    this.state = Object.assign(this.defaults, this.props.query);\n  }\n\n  async componentDidMount() {\n    const metricDescriptors = await this.props.datasource.getMetricTypes(this.props.datasource.projectName);\n    const services = extractServicesFromMetricDescriptors(metricDescriptors).map((m: any) => ({\n      value: m.service,\n      name: m.serviceShortName,\n    }));\n\n    let selectedService = '';\n    if (services.some(s => s.value === this.props.templateSrv.replace(this.state.selectedService))) {\n      selectedService = this.state.selectedService;\n    } else if (services && services.length > 0) {\n      selectedService = services[0].value;\n    }\n\n    const { metricTypes, selectedMetricType } = getMetricTypes(\n      metricDescriptors,\n      this.state.selectedMetricType,\n      this.props.templateSrv.replace(this.state.selectedMetricType),\n      this.props.templateSrv.replace(selectedService)\n    );\n    const state: any = {\n      services,\n      selectedService,\n      metricTypes,\n      selectedMetricType,\n      metricDescriptors,\n      ...(await this.getLabels(selectedMetricType)),\n    };\n    this.setState(state);\n  }\n\n  async onQueryTypeChange(event: ChangeEvent<HTMLSelectElement>) {\n    const state: any = {\n      selectedQueryType: event.target.value,\n      ...(await this.getLabels(this.state.selectedMetricType, event.target.value)),\n    };\n    this.setState(state);\n  }\n\n  async onServiceChange(event: ChangeEvent<HTMLSelectElement>) {\n    const { metricTypes, selectedMetricType } = getMetricTypes(\n      this.state.metricDescriptors,\n      this.state.selectedMetricType,\n      this.props.templateSrv.replace(this.state.selectedMetricType),\n      this.props.templateSrv.replace(event.target.value)\n    );\n    const state: any = {\n      selectedService: event.target.value,\n      metricTypes,\n      selectedMetricType,\n      ...(await this.getLabels(selectedMetricType)),\n    };\n    this.setState(state);\n  }\n\n  async onMetricTypeChange(event: ChangeEvent<HTMLSelectElement>) {\n    const state: any = { selectedMetricType: event.target.value, ...(await this.getLabels(event.target.value)) };\n    this.setState(state);\n  }\n\n  onLabelKeyChange(event: ChangeEvent<HTMLSelectElement>) {\n    this.setState({ labelKey: event.target.value });\n  }\n\n  componentDidUpdate() {\n    const { metricDescriptors, labels, metricTypes, services, ...queryModel } = this.state;\n    const query = this.queryTypes.find(q => q.value === this.state.selectedQueryType);\n    this.props.onChange(queryModel, `Stackdriver - ${query.name}`);\n  }\n\n  async getLabels(selectedMetricType: string, selectedQueryType = this.state.selectedQueryType) {\n    let result = { labels: this.state.labels, labelKey: this.state.labelKey };\n    if (selectedMetricType && selectedQueryType === MetricFindQueryTypes.LabelValues) {\n      const labels = await getLabelKeys(this.props.datasource, selectedMetricType);\n      const labelKey = labels.some(l => l === this.props.templateSrv.replace(this.state.labelKey))\n        ? this.state.labelKey\n        : labels[0];\n      result = { labels, labelKey };\n    }\n    return result;\n  }\n\n  insertTemplateVariables(options: any) {\n    const templateVariables = this.props.templateSrv.variables.map((v: any) => ({\n      name: `$${v.name}`,\n      value: `$${v.name}`,\n    }));\n    return [...templateVariables, ...options];\n  }\n\n  renderQueryTypeSwitch(queryType: string) {\n    switch (queryType) {\n      case MetricFindQueryTypes.MetricTypes:\n        return (\n          <SimpleSelect\n            value={this.state.selectedService}\n            options={this.insertTemplateVariables(this.state.services)}\n            onValueChange={e => this.onServiceChange(e)}\n            label=\"Service\"\n          />\n        );\n      case MetricFindQueryTypes.LabelKeys:\n      case MetricFindQueryTypes.LabelValues:\n      case MetricFindQueryTypes.ResourceTypes:\n        return (\n          <>\n            <SimpleSelect\n              value={this.state.selectedService}\n              options={this.insertTemplateVariables(this.state.services)}\n              onValueChange={e => this.onServiceChange(e)}\n              label=\"Service\"\n            />\n            <SimpleSelect\n              value={this.state.selectedMetricType}\n              options={this.insertTemplateVariables(this.state.metricTypes)}\n              onValueChange={e => this.onMetricTypeChange(e)}\n              label=\"Metric Type\"\n            />\n            {queryType === MetricFindQueryTypes.LabelValues && (\n              <SimpleSelect\n                value={this.state.labelKey}\n                options={this.insertTemplateVariables(this.state.labels.map(l => ({ value: l, name: l })))}\n                onValueChange={e => this.onLabelKeyChange(e)}\n                label=\"Label Key\"\n              />\n            )}\n          </>\n        );\n      case MetricFindQueryTypes.Aligners:\n      case MetricFindQueryTypes.Aggregations:\n        return (\n          <>\n            <SimpleSelect\n              value={this.state.selectedService}\n              options={this.insertTemplateVariables(this.state.services)}\n              onValueChange={e => this.onServiceChange(e)}\n              label=\"Service\"\n            />\n            <SimpleSelect\n              value={this.state.selectedMetricType}\n              options={this.insertTemplateVariables(this.state.metricTypes)}\n              onValueChange={e => this.onMetricTypeChange(e)}\n              label=\"Metric Type\"\n            />\n          </>\n        );\n      default:\n        return '';\n    }\n  }\n\n  render() {\n    return (\n      <>\n        <SimpleSelect\n          value={this.state.selectedQueryType}\n          options={this.queryTypes}\n          onValueChange={e => this.onQueryTypeChange(e)}\n          label=\"Query Type\"\n        />\n        {this.renderQueryTypeSwitch(this.state.selectedQueryType)}\n      </>\n    );\n  }\n}\n","import DatasourceSrv from 'app/features/plugins/datasource_srv';\n\nexport interface JWT {\n  private_key: any;\n  token_uri: any;\n  client_email: any;\n  project_id: any;\n}\n\nexport class StackdriverConfigCtrl {\n  static templateUrl = 'public/app/plugins/datasource/stackdriver/partials/config.html';\n  datasourceSrv: any;\n  current: any;\n  jsonText: string;\n  validationErrors: string[] = [];\n  inputDataValid: boolean;\n  authenticationTypes: any[];\n  defaultAuthenticationType: string;\n\n  /** @ngInject */\n  constructor(datasourceSrv: DatasourceSrv) {\n    this.defaultAuthenticationType = 'jwt';\n    this.datasourceSrv = datasourceSrv;\n    this.current.jsonData = this.current.jsonData || {};\n    this.current.jsonData.authenticationType = this.current.jsonData.authenticationType\n      ? this.current.jsonData.authenticationType\n      : this.defaultAuthenticationType;\n    this.current.secureJsonData = this.current.secureJsonData || {};\n    this.current.secureJsonFields = this.current.secureJsonFields || {};\n    this.authenticationTypes = [\n      { key: this.defaultAuthenticationType, value: 'Google JWT File' },\n      { key: 'gce', value: 'GCE Default Service Account' },\n    ];\n  }\n\n  save(jwt: JWT) {\n    this.current.secureJsonData.privateKey = jwt.private_key;\n    this.current.jsonData.tokenUri = jwt.token_uri;\n    this.current.jsonData.clientEmail = jwt.client_email;\n    this.current.jsonData.defaultProject = jwt.project_id;\n  }\n\n  validateJwt(jwt: JWT) {\n    this.resetValidationMessages();\n    if (!jwt.private_key || jwt.private_key.length === 0) {\n      this.validationErrors.push('Private key field missing in JWT file.');\n    }\n\n    if (!jwt.token_uri || jwt.token_uri.length === 0) {\n      this.validationErrors.push('Token URI field missing in JWT file.');\n    }\n\n    if (!jwt.client_email || jwt.client_email.length === 0) {\n      this.validationErrors.push('Client Email field missing in JWT file.');\n    }\n\n    if (!jwt.project_id || jwt.project_id.length === 0) {\n      this.validationErrors.push('Project Id field missing in JWT file.');\n    }\n\n    if (this.validationErrors.length === 0) {\n      this.inputDataValid = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  onUpload(json: JWT) {\n    this.jsonText = '';\n    if (this.validateJwt(json)) {\n      this.save(json);\n    }\n  }\n\n  onPasteJwt(e: any) {\n    try {\n      const json = JSON.parse(e.originalEvent.clipboardData.getData('text/plain') || this.jsonText);\n      if (this.validateJwt(json)) {\n        this.save(json);\n      }\n    } catch (error) {\n      this.resetValidationMessages();\n      this.validationErrors.push(`Invalid json: ${error.message}`);\n    }\n  }\n\n  resetValidationMessages() {\n    this.validationErrors = [];\n    this.inputDataValid = false;\n    this.jsonText = '';\n\n    this.current.jsonData = Object.assign({}, { authenticationType: this.current.jsonData.authenticationType });\n    this.current.secureJsonData = {};\n    this.current.secureJsonFields = {};\n  }\n}\n","import { stackdriverUnitMappings } from './constants';\nimport appEvents from 'app/core/app_events';\nimport _ from 'lodash';\nimport StackdriverMetricFindQuery from './StackdriverMetricFindQuery';\nimport { StackdriverQuery, MetricDescriptor, StackdriverOptions, Filter } from './types';\nimport { DataSourceApi, DataQueryRequest, DataSourceInstanceSettings, ScopedVars } from '@grafana/data';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { CoreEvents } from 'app/types';\n\nexport default class StackdriverDatasource extends DataSourceApi<StackdriverQuery, StackdriverOptions> {\n  url: string;\n  baseUrl: string;\n  projectName: string;\n  authenticationType: string;\n  queryPromise: Promise<any>;\n  metricTypes: any[];\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<StackdriverOptions>,\n    private backendSrv: BackendSrv,\n    public templateSrv: TemplateSrv,\n    private timeSrv: TimeSrv\n  ) {\n    super(instanceSettings);\n    this.baseUrl = `/stackdriver/`;\n    this.url = instanceSettings.url;\n    this.projectName = instanceSettings.jsonData.defaultProject || '';\n    this.authenticationType = instanceSettings.jsonData.authenticationType || 'jwt';\n    this.metricTypes = [];\n  }\n\n  get variables() {\n    return this.templateSrv.variables.map(v => `$${v.name}`);\n  }\n\n  async getTimeSeries(options: any) {\n    const queries = options.targets\n      .filter((target: any) => {\n        return !target.hide && target.metricType;\n      })\n      .map((t: any) => {\n        return {\n          refId: t.refId,\n          intervalMs: options.intervalMs,\n          datasourceId: this.id,\n          metricType: this.templateSrv.replace(t.metricType, options.scopedVars || {}),\n          crossSeriesReducer: this.templateSrv.replace(t.crossSeriesReducer || 'REDUCE_MEAN', options.scopedVars || {}),\n          perSeriesAligner: this.templateSrv.replace(t.perSeriesAligner, options.scopedVars || {}),\n          alignmentPeriod: this.templateSrv.replace(t.alignmentPeriod, options.scopedVars || {}),\n          groupBys: this.interpolateGroupBys(t.groupBys, options.scopedVars),\n          view: t.view || 'FULL',\n          filters: this.interpolateFilters(t.filters, options.scopedVars),\n          aliasBy: this.templateSrv.replace(t.aliasBy, options.scopedVars || {}),\n          type: 'timeSeriesQuery',\n        };\n      });\n\n    if (queries.length > 0) {\n      const { data } = await this.backendSrv.datasourceRequest({\n        url: '/api/tsdb/query',\n        method: 'POST',\n        data: {\n          from: options.range.from.valueOf().toString(),\n          to: options.range.to.valueOf().toString(),\n          queries,\n        },\n      });\n      return data;\n    } else {\n      return { results: [] };\n    }\n  }\n\n  interpolateFilters(filters: string[], scopedVars: ScopedVars) {\n    const completeFilter = _.chunk(filters, 4)\n      .map(([key, operator, value, condition = 'AND']) => ({\n        key,\n        operator,\n        value,\n        condition,\n      }))\n      .reduce((res, filter) => (filter.value ? [...res, filter] : res), []);\n\n    const filterArray = _.flatten(\n      completeFilter.map(({ key, operator, value, condition }: Filter) => [key, operator, value, condition])\n    );\n\n    return (filterArray || []).map(f => {\n      return this.templateSrv.replace(f, scopedVars || {}, 'regex');\n    });\n  }\n\n  async getLabels(metricType: string, refId: string, groupBys?: string[]) {\n    const response = await this.getTimeSeries({\n      targets: [\n        {\n          refId: refId,\n          datasourceId: this.id,\n          metricType: this.templateSrv.replace(metricType),\n          groupBys: this.interpolateGroupBys(groupBys || [], {}),\n          crossSeriesReducer: 'REDUCE_NONE',\n          view: 'HEADERS',\n        },\n      ],\n      range: this.timeSrv.timeRange(),\n    });\n    const result = response.results[refId];\n    return result && result.meta ? result.meta.labels : {};\n  }\n\n  interpolateGroupBys(groupBys: string[], scopedVars: {}): string[] {\n    let interpolatedGroupBys: any[] = [];\n    (groupBys || []).forEach(gb => {\n      const interpolated = this.templateSrv.replace(gb, scopedVars || {}, 'csv').split(',');\n      if (Array.isArray(interpolated)) {\n        interpolatedGroupBys = interpolatedGroupBys.concat(interpolated);\n      } else {\n        interpolatedGroupBys.push(interpolated);\n      }\n    });\n    return interpolatedGroupBys;\n  }\n\n  resolvePanelUnitFromTargets(targets: any[]) {\n    let unit;\n    if (targets.length > 0 && targets.every(t => t.unit === targets[0].unit)) {\n      if (stackdriverUnitMappings.hasOwnProperty(targets[0].unit)) {\n        // @ts-ignore\n        unit = stackdriverUnitMappings[targets[0].unit];\n      }\n    }\n    return unit;\n  }\n\n  async query(options: DataQueryRequest<StackdriverQuery>) {\n    const result: any[] = [];\n    const data = await this.getTimeSeries(options);\n    if (data.results) {\n      Object['values'](data.results).forEach((queryRes: any) => {\n        if (!queryRes.series) {\n          return;\n        }\n        const unit = this.resolvePanelUnitFromTargets(options.targets);\n        queryRes.series.forEach((series: any) => {\n          let timeSerie: any = {\n            target: series.name,\n            datapoints: series.points,\n            refId: queryRes.refId,\n            meta: queryRes.meta,\n          };\n          if (unit) {\n            timeSerie = { ...timeSerie, unit };\n          }\n          result.push(timeSerie);\n        });\n      });\n      return { data: result };\n    } else {\n      return { data: [] };\n    }\n  }\n\n  async annotationQuery(options: any) {\n    const annotation = options.annotation;\n    const queries = [\n      {\n        refId: 'annotationQuery',\n        datasourceId: this.id,\n        metricType: this.templateSrv.replace(annotation.target.metricType, options.scopedVars || {}),\n        crossSeriesReducer: 'REDUCE_NONE',\n        perSeriesAligner: 'ALIGN_NONE',\n        title: this.templateSrv.replace(annotation.target.title, options.scopedVars || {}),\n        text: this.templateSrv.replace(annotation.target.text, options.scopedVars || {}),\n        tags: this.templateSrv.replace(annotation.target.tags, options.scopedVars || {}),\n        view: 'FULL',\n        filters: this.interpolateFilters(annotation.target.filters || [], options.scopedVars),\n        type: 'annotationQuery',\n      },\n    ];\n\n    const { data } = await this.backendSrv.datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        from: options.range.from.valueOf().toString(),\n        to: options.range.to.valueOf().toString(),\n        queries,\n      },\n    });\n\n    const results = data.results['annotationQuery'].tables[0].rows.map((v: any) => {\n      return {\n        annotation: annotation,\n        time: Date.parse(v[0]),\n        title: v[1],\n        tags: [],\n        text: v[3],\n      } as any;\n    });\n\n    return results;\n  }\n\n  async metricFindQuery(query: string) {\n    const stackdriverMetricFindQuery = new StackdriverMetricFindQuery(this);\n    return stackdriverMetricFindQuery.execute(query);\n  }\n\n  async testDatasource() {\n    let status, message;\n    const defaultErrorMessage = 'Cannot connect to Stackdriver API';\n    try {\n      const projectName = await this.getDefaultProject();\n      const path = `v3/projects/${projectName}/metricDescriptors`;\n      const response = await this.doRequest(`${this.baseUrl}${path}`);\n      if (response.status === 200) {\n        status = 'success';\n        message = 'Successfully queried the Stackdriver API.';\n      } else {\n        status = 'error';\n        message = response.statusText ? response.statusText : defaultErrorMessage;\n      }\n    } catch (error) {\n      status = 'error';\n      if (_.isString(error)) {\n        message = error;\n      } else {\n        message = 'Stackdriver: ';\n        message += error.statusText ? error.statusText : defaultErrorMessage;\n        if (error.data && error.data.error && error.data.error.code) {\n          message += ': ' + error.data.error.code + '. ' + error.data.error.message;\n        }\n      }\n    } finally {\n      return {\n        status,\n        message,\n      };\n    }\n  }\n\n  formatStackdriverError(error: any) {\n    let message = 'Stackdriver: ';\n    message += error.statusText ? error.statusText + ': ' : '';\n    if (error.data && error.data.error) {\n      try {\n        const res = JSON.parse(error.data.error);\n        message += res.error.code + '. ' + res.error.message;\n      } catch (err) {\n        message += error.data.error;\n      }\n    } else {\n      message += 'Cannot connect to Stackdriver API';\n    }\n    return message;\n  }\n\n  async getDefaultProject() {\n    try {\n      if (this.authenticationType === 'gce' || !this.projectName) {\n        const { data } = await this.backendSrv.datasourceRequest({\n          url: '/api/tsdb/query',\n          method: 'POST',\n          data: {\n            queries: [\n              {\n                refId: 'ensureDefaultProjectQuery',\n                type: 'ensureDefaultProjectQuery',\n                datasourceId: this.id,\n              },\n            ],\n          },\n        });\n        this.projectName = data.results.ensureDefaultProjectQuery.meta.defaultProject;\n        return this.projectName;\n      } else {\n        return this.projectName;\n      }\n    } catch (error) {\n      throw this.formatStackdriverError(error);\n    }\n  }\n\n  async getMetricTypes(projectName: string): Promise<MetricDescriptor[]> {\n    try {\n      if (this.metricTypes.length === 0) {\n        const metricsApiPath = `v3/projects/${projectName}/metricDescriptors`;\n        const { data } = await this.doRequest(`${this.baseUrl}${metricsApiPath}`);\n\n        this.metricTypes = data.metricDescriptors.map((m: any) => {\n          const [service] = m.type.split('/');\n          const [serviceShortName] = service.split('.');\n          m.service = service;\n          m.serviceShortName = serviceShortName;\n          m.displayName = m.displayName || m.type;\n\n          return m;\n        });\n      }\n\n      return this.metricTypes;\n    } catch (error) {\n      appEvents.emit(CoreEvents.dsRequestError, { error: { data: { error: this.formatStackdriverError(error) } } });\n      return [];\n    }\n  }\n\n  async doRequest(url: string, maxRetries = 1) {\n    return this.backendSrv\n      .datasourceRequest({\n        url: this.url + url,\n        method: 'GET',\n      })\n      .catch((error: any) => {\n        if (maxRetries > 0) {\n          return this.doRequest(url, maxRetries - 1);\n        }\n\n        throw error;\n      });\n  }\n}\n","import StackdriverDatasource from './datasource';\nimport { StackdriverQueryCtrl } from './query_ctrl';\nimport { StackdriverConfigCtrl } from './config_ctrl';\nimport { StackdriverAnnotationsQueryCtrl } from './annotations_query_ctrl';\nimport { StackdriverVariableQueryEditor } from './components/VariableQueryEditor';\n\nexport {\n  StackdriverDatasource as Datasource,\n  StackdriverQueryCtrl as QueryCtrl,\n  StackdriverConfigCtrl as ConfigCtrl,\n  StackdriverAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n  StackdriverVariableQueryEditor as VariableQueryEditor,\n};\n","import { QueryCtrl } from 'app/plugins/sdk';\nimport { StackdriverQuery } from './types';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { auto } from 'angular';\n\nexport class StackdriverQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n  templateSrv: TemplateSrv;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService, templateSrv: TemplateSrv) {\n    super($scope, $injector);\n    this.templateSrv = templateSrv;\n    this.onQueryChange = this.onQueryChange.bind(this);\n    this.onExecuteQuery = this.onExecuteQuery.bind(this);\n  }\n\n  onQueryChange(target: StackdriverQuery) {\n    Object.assign(this.target, target);\n  }\n\n  onExecuteQuery() {\n    this.$scope.ctrl.refresh();\n  }\n}\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\n\nexport enum MetricFindQueryTypes {\n  Services = 'services',\n  MetricTypes = 'metricTypes',\n  LabelKeys = 'labelKeys',\n  LabelValues = 'labelValues',\n  ResourceTypes = 'resourceTypes',\n  Aggregations = 'aggregations',\n  Aligners = 'aligners',\n  AlignmentPeriods = 'alignmentPeriods',\n}\n\nexport interface VariableQueryData {\n  selectedQueryType: string;\n  metricDescriptors: any[];\n  selectedService: string;\n  selectedMetricType: string;\n  labels: string[];\n  labelKey: string;\n  metricTypes: Array<{ value: string; name: string }>;\n  services: Array<{ value: string; name: string }>;\n}\n\nexport interface StackdriverQuery extends DataQuery {\n  defaultProject?: string;\n  unit?: string;\n  metricType: string;\n  service?: string;\n  refId: string;\n  crossSeriesReducer: string;\n  alignmentPeriod?: string;\n  perSeriesAligner: string;\n  groupBys?: string[];\n  filters?: string[];\n  aliasBy?: string;\n  metricKind: string;\n  valueType: string;\n  datasourceId?: number;\n  view?: string;\n}\n\nexport interface StackdriverOptions extends DataSourceJsonData {\n  defaultProject?: string;\n  authenticationType?: string;\n}\n\nexport interface AnnotationTarget {\n  defaultProject: string;\n  metricType: string;\n  refId: string;\n  filters: string[];\n  metricKind: string;\n  valueType: string;\n  title: string;\n  text: string;\n}\n\nexport interface QueryMeta {\n  alignmentPeriod: string;\n  rawQuery: string;\n  rawQueryString: string;\n  metricLabels: { [key: string]: string[] };\n  resourceLabels: { [key: string]: string[] };\n  resourceTypes: string[];\n}\n\nexport interface MetricDescriptor {\n  valueType: string;\n  metricKind: string;\n  type: string;\n  unit: string;\n  service: string;\n  serviceShortName: string;\n  displayName: string;\n  description: string;\n}\n\nexport interface Segment {\n  type: string;\n  value: string;\n}\n\nexport interface Filter {\n  key: string;\n  operator: string;\n  value: string;\n  condition: string;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAQA;AACA;AAAA;AAAA;AAEA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AACA;AAEA;;;;;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;AAEA;AACA;AACA;AACA;;;;AAEA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;AACA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;;;;AACA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;AACA;AAEA;AAAA;;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;AAGA;;;;AACA;AAEA;AAAA;;;;;;;AACA;AACA;AACA;AACA;;AAAA;AACA;AAGA;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACzHA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAZA;AAaA;AAAA;AAdA;;;;;;;;;;;;;;;;;;;;;;ACFA;AAEA;AACA;AACA;AAEA;AAAA;AAuBA;AAAA;AAtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AACA;AAEA;;;;;;AACA;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;;AANA;AAQA;;;;;AACA;AAEA;;;;;;AAEA;AACA;;AAFA;AAIA;;;;;AACA;AAEA;;;;;;AACA;AAOA;AAEA;AACA;;AAJA;AAMA;;;;;AACA;AAEA;;;;;;AACA;AAAA;;AAAA;AACA;;;;;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;;AAEA;;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AAMA;AAMA;AAUA;AACA;AACA;AAEA;AAMA;AAQA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAMA;AAGA;AACA;AAAA;;;;;;;;;;;;;;AC7LA;AAAA;AAAA;AAUA;AACA;AANA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AArFA;AAsFA;AAAA;AAvFA;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AAAA;AAQA;AACA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAAA;AACA;AACA;;;AAAA;AAEA;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AARA;AASA;AAEA;;;;AAEA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAEA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAZA;AAaA;AACA;;;;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AACA;AAEA;;;;AACA;AACA;;;AACA;AAEA;;;;;;AAEA;;;;AAEA;;AAAA;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAZA;AAaA;AACA;AAEA;;;;AAGA;;;;;AAEA;AAEA;AAAA;;;;;;AAEA;AACA;AACA;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;;;AAEA;AACA;;;;;AAEA;AAEA;AAAA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AACA;AACA;AAAA;;;;;;;;;;;;;;ACpUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;ACNA;AAKA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAjBA;AAkBA;AAAA;AAnBA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}